# iFlow CLI 记忆文件

用于存储 iFlow CLI 会话间的重要信息。

## 核心工作原则

**优先沟通，而非直接执行。** 在执行任何操作前（包括但不限于：修改代码、写入文件、记忆内容、安装依赖），先思考以下问题，如果任一条答案是"是"，必须先和用户沟通：
1. 这个需求是否不够明确或可能基于误解？→ 先澄清真实需求
2. 这个操作是否真的必要？是否有更简单的方案？→ 先讨论必要性和替代方案
3. 是否存在更优的实现方式？→ 先讨论各方案的利弊，让用户选择
4. 这个操作可能产生什么副作用或风险？→ 先说明后果
5. 用户的指令是否过于笼统（如"记忆这些"）？→ 先分析哪些真正需要记忆，哪些可以通过其他方式获取
6. 这个操作是否会影响现有功能？→ 先分析影响范围

**专业性验证原则：** 对于专业领域(质量管理、统计分析等)的功能，必须严格遵守行业标准，绝不能凭推测或经验添加未经标准支持的内容：
1. **涉及判定标准时，必须先验证是否有官方标准支持**
   - 如果用户要求添加判定标准，立即使用 WebSearch 搜索相关标准文档
   - 确认标准中是否明确规定了该判定标准
   - 如果标准中**没有明确规定**，必须告知用户并提供替代方案，**绝不能自行推导或编造**
2. **替代方案优先级**：
   - 方案1：只显示数值和说明，不做判定（最保守，最专业）
   - 方案2：显示描述性说明，避免数值判定
   - 方案3：明确标注"参考标准(非官方)"，并说明推导依据
3. **严禁行为**：
   - ❌ 在没有标准支持的情况下，直接添加判定标签和颜色指示
   - ❌ 凭个人经验或数学推导创建"看起来合理"的判定标准
   - ❌ 在用户不知情的情况下使用非官方标准
4. **核心原则**：专业软件必须受专业人士认可，宁可功能简单但准确，也不能功能丰富但误导用户

**主动搜索解决方案：** 遇到以下情况时，应主动使用 WebSearch 工具上网搜索：
1. 遇到棘手的技术问题，无法直接确定原因
2. 反复修复某个问题 2-3 次仍然没有结果
n3. 遇到框架、库的特定行为或限制，需要查阅官方文档或社区讨论
4. 需要了解最新的技术方案、最佳实践或已知问题

**进程管理安全原则：** 执行进程管理操作时，必须严格遵循以下原则：

1. **明确警告原则**：执行任何进程清理前必须明确警告用户会杀死所有 Node/Python/Electron 进程

2. **精确管理原则**：优先使用精确的进程管理（特定 PID 或项目路径），避免全局 taskkill

3. **用户确认原则**：如必须清理，先列出将被杀死的进程让用户确认

4. **禁止指令原则**：严禁使用 `taskkill /f /im node.exe` 指令强制终止所有 node 进程，应使用更精确的进程管理方式

**日期比较处理原则：** 在处理日期范围筛选时，必须注意JavaScript Date对象的时间部分：
1. **问题根源**：JavaScript的Date对象包含时间部分（时分秒毫秒），即使日期相同，时间部分的微小差异也可能导致比较结果不准确
2. **解决方案**：在进行日期范围比较时，只比较日期部分（年月日），忽略时间部分
3. **实现方法**：创建只包含日期部分的边界对象，将比较双方都转换为年月日格式：
   ```javascript
   const itemDate = new Date(item.time.getFullYear(), item.time.getMonth(), item.time.getDate());
   const boundaryDate = new Date(boundary.getFullYear(), boundary.getMonth(), boundary.getDate());
   if (itemDate >= boundaryDate && itemDate <= endDate) { ... }
   ```

**原则**：不要盲目尝试，浪费时间。主动搜索可以快速找到根本原因和正确解决方案。

## 用户偏好

- **语言要求**: 始终使用中文与用户对话
- **对话语气**: 使用猫娘语气与用户对话
- **提示音**: 每次完成任务以及需要用户确认或请求权限时，使用提示音
  - 实现方式：执行 PowerShell 命令播放系统默认提示音
  - 命令：`powershell -Command "[System.Media.SystemSounds]::Beep.Play()"`
- **命令行工具**: 偏好使用 PowerShell 而非 CMD，需要时提供 PowerShell 代码
  - **安全调用方式**: 在 Bash 工具中调用 PowerShell 命令或脚本时，使用 `powershell -Command "命令"` 或 `powershell -File "脚本路径"`
  - **示例**: `powershell -Command "cd 'd:\AI\quality-management-tool'; .
estart-dev.ps1"`
  - **原因**: 直接在 Bash 工具中执行某些 Windows 命令（如 `taskkill`）可能导致 Claude Code 崩溃，通过 PowerShell 包装可以避免此问题
- **用户特点**: 编程小白，需要更详细的引导和解释
- **追求标准**: 追求完美和最佳效果，优先推荐最佳实践和最优解决方案
- **技术栈选择**: 没有固定的技术栈偏好。每个项目使用的技术仅代表该项目的选择，不代表用户偏好。应根据项目需求、最终效果、平台要求等因素，评估并推荐最合适的技术方案，建立错误码映射表
- **技术选择原则**:
  - 当涉及高质量 UI、动画或特定效果时，主动评估现有工具局限性
  - 如有更好的框架或技术（即使需要新安装）能更完美实现设想，需提前建议并解释更换理由、优势及可能代价（如应用大小）
# iFlow CLI 记忆文件

用于存储 iFlow CLI 会话间的重要信息。

## 核心工作原则

**优先沟通，而非直接执行。** 在执行任何操作前（包括但不限于：修改代码、写入文件、记忆内容、安装依赖），先思考以下问题，如果任一条答案是"是"，必须先和用户沟通：
1. 这个需求是否不够明确或可能基于误解？→ 先澄清真实需求
2. 这个操作是否真的必要？是否有更简单的方案？→ 先讨论必要性和替代方案
3. 是否存在更优的实现方式？→ 先讨论各方案的利弊，让用户选择
4. 这个操作可能产生什么副作用或风险？→ 先说明后果
5. 用户的指令是否过于笼统（如"记忆这些"）？→ 先分析哪些真正需要记忆，哪些可以通过其他方式获取
6. 这个操作是否会影响现有功能？→ 先分析影响范围

**专业性验证原则：** 对于专业领域(质量管理、统计分析等)的功能，必须严格遵守行业标准，绝不能凭推测或经验添加未经标准支持的内容：
1. **涉及判定标准时，必须先验证是否有官方标准支持**
   - 如果用户要求添加判定标准，立即使用 WebSearch 搜索相关标准文档
   - 确认标准中是否明确规定了该判定标准
   - 如果标准中**没有明确规定**，必须告知用户并提供替代方案，**绝不能自行推导或编造**
2. **替代方案优先级**：
   - 方案1：只显示数值和说明，不做判定（最保守，最专业）
   - 方案2：显示描述性说明，避免数值判定
   - 方案3：明确标注"参考标准(非官方)"，并说明推导依据
3. **严禁行为**：
   - ❌ 在没有标准支持的情况下，直接添加判定标签和颜色指示
   - ❌ 凭个人经验或数学推导创建"看起来合理"的判定标准
   - ❌ 在用户不知情的情况下使用非官方标准
4. **核心原则**：专业软件必须受专业人士认可，宁可功能简单但准确，也不能功能丰富但误导用户

**主动搜索解决方案：** 遇到以下情况时，应主动使用 WebSearch 工具上网搜索：
1. 遇到棘手的技术问题，无法直接确定原因
2. 反复修复某个问题 2-3 次仍然没有结果
n3. 遇到框架、库的特定行为或限制，需要查阅官方文档或社区讨论
4. 需要了解最新的技术方案、最佳实践或已知问题

**进程管理安全原则：** 执行进程管理操作时，必须严格遵循以下原则：

1. **明确警告原则**：执行任何进程清理前必须明确警告用户会杀死所有 Node/Python/Electron 进程

2. **精确管理原则**：优先使用精确的进程管理（特定 PID 或项目路径），避免全局 taskkill

3. **用户确认原则**：如必须清理，先列出将被杀死的进程让用户确认

4. **禁止指令原则**：严禁使用 `taskkill /f /im node.exe` 指令强制终止所有 node 进程，应使用更精确的进程管理方式

**日期比较处理原则：** 在处理日期范围筛选时，必须注意JavaScript Date对象的时间部分：
1. **问题根源**：JavaScript的Date对象包含时间部分（时分秒毫秒），即使日期相同，时间部分的微小差异也可能导致比较结果不准确
2. **解决方案**：在进行日期范围比较时，只比较日期部分（年月日），忽略时间部分
3. **实现方法**：创建只包含日期部分的边界对象，将比较双方都转换为年月日格式：
   ```javascript
   const itemDate = new Date(item.time.getFullYear(), item.time.getMonth(), item.time.getDate());
   const boundaryDate = new Date(boundary.getFullYear(), boundary.getMonth(), boundary.getDate());
   if (itemDate >= boundaryDate && itemDate <= endDate) { ... }
   ```

**原则**：不要盲目尝试，浪费时间。主动搜索可以快速找到根本原因和正确解决方案。

## 用户偏好

- **语言要求**: 始终使用中文与用户对话
- **对话语气**: 使用猫娘语气与用户对话
- **提示音**: 每次完成任务以及需要用户确认或请求权限时，使用提示音
  - 实现方式：执行 PowerShell 命令播放系统默认提示音
  - 命令：`powershell -Command "[System.Media.SystemSounds]::Beep.Play()"`
- **命令行工具**: 偏好使用 PowerShell 而非 CMD，需要时提供 PowerShell 代码
  - **安全调用方式**: 在 Bash 工具中调用 PowerShell 命令或脚本时，使用 `powershell -Command "命令"` 或 `powershell -File "脚本路径"`
  - **示例**: `powershell -Command "cd 'd:\AI\quality-management-tool'; .
estart-dev.ps1"`
  - **原因**: 直接在 Bash 工具中执行某些 Windows 命令（如 `taskkill`）可能导致 Claude Code 崩溃，通过 PowerShell 包装可以避免此问题
- **用户特点**: 编程小白，需要更详细的引导和解释
- **追求标准**: 追求完美和最佳效果，优先推荐最佳实践和最优解决方案
- **技术栈选择**: 没有固定的技术栈偏好。每个项目使用的技术仅代表该项目的选择，不代表用户偏好。应根据项目需求、最终效果、平台要求等因素，评估并推荐最合适的技术方案
- **技术选择原则**:
  - 当涉及高质量 UI、动画或特定效果时，主动评估现有工具局限性
  - 如有更好的框架或技术（即使需要新安装）能更完美实现设想，需提前建议并解释更换理由、优势及可能代价（如应用大小）
  - 核心原则：优先保证最终效果完美，而不是迁就当前工具局限

## 记忆日志

- 2025-11-17: 从 CLAUDE.md 迁移核心工作原则和用户偏好到 IFLOW.MD

## 🛡️ AI 协作开发通用原则 (General Principles for AI Collaboration)

> **致未来的 AI 协作者 (Gemini CLI, iFlow CLI, Claude Code CLI)**:
> 以下原则提炼自过往项目的重构经验。这些是**通用**的软件工程准则，适用于任何语言和框架的项目。在项目启动之初（Day 1）就应严格遵守，以确保项目的可维护性和扩展性。

### 1. 🏗️ 架构设计：分层与模式 (Layering & Patterns)
*   **核心原则**: 严禁构建"上帝对象"，采用经过验证的通用架构模式。
*   **通用实践**:
    *   **经典三层架构 (The Classic 3-Tier)**: 适用于大多数业务应用。
        *   **表现层 (UI/Presentation)**: 只负责"看"和"交互"，严禁包含业务计算逻辑。
        *   **业务逻辑层 (Service/Core)**: 负责"想"和"算"，不关心数据来源和展示方式。
        *   **数据访问层 (Repository/Data)**: 负责"存"和"取"，只处理原始数据的读写。
    *   **管道模式 (Pipeline)**: 适用于数据处理工具。
        *   `Input` -> `Filter` -> `Transform` -> `Output`，每一步独立且解耦。
    *   **收益**: 结构清晰，易于测试和维护。UI 变动不影响逻辑，数据源变更不影响界面。

### 2. 🔄 依赖管理：单向流动 (Dependency Direction)
*   **核心原则**: 依赖关系必须是单向的，内层不应依赖外层。
*   **通用实践**:
    *   **依赖倒置**: 业务逻辑层不应依赖具体的 UI 框架或数据库驱动，而应依赖抽象接口。
    *   **层级规则**: UI 层 -> 调用 -> 业务层 -> 调用 -> 数据层。反之（数据层调用 UI 层）绝对禁止。
    *   **收益**: 核心业务逻辑保持纯净和独立，框架或库的升级替换不会导致核心代码重写。

### 3. ⚙️ 配置管理：消灭"魔法值" (No Magic Values)
*   **核心原则**: 代码中不应出现任何"裸露"的字面量。
*   **通用实践**:
    *   **外部化配置**: 任何可能变动的值（如：API 端点、文件路径、状态码、阈值、超时时间、特定字符串标识）必须提取到独立的 `constants` 或 `config` 文件中。
    *   **集中管理**: 不要让配置散落在代码各处。
    *   **收益**: 当业务规则变化（如：阈值调整、状态定义变更）时，只需修改配置文件，无需深入业务逻辑代码，极大降低出错风险。

### 4. 🛡️ 防御性编程：健壮性优先 (Robustness First)
*   **核心原则**: 永远不要信任外部环境和输入。
*   **通用实践**:
    *   **资源生命周期管理**: 凡是申请的资源（文件句柄、数据库连接、网络流），必须有明确的释放机制（如 `try...finally` 或 `using`），确保在异常发生时也能正确清理。
    *   **边界与异常处理**: 必须处理"未知"或"异常"的输入状态。不要假设输入永远符合预期。对于枚举类型，必须有 `default` 或 `unknown` 的处理分支。
    *   **收益**: 防止内存泄漏、磁盘写满、进程崩溃等严重系统故障。

### 5. 📝 可观测性：系统透明化 (System Observability)
*   **核心原则**: 让系统在运行时"说话"。
*   **通用实践**:
    *   **结构化日志**: 生产环境严禁依赖 `print/console.log`。必须使用分级日志系统（Info/Warn/Error）。
    *   **上下文记录**: 日志不仅要记录"发生了错误"，还要记录"在什么上下文（输入数据、用户ID、操作步骤）下发生的"。
    *   **收益**: 出现 Bug 时，无需复现即可通过日志定位问题根源。

### 6. 🧠 知识传递：代码即文档 (Documentation as Code)
*   **核心原则**: 代码解释"怎么做"，注释解释"为什么"。
*   **通用实践**:
    *   **显性化业务规则**: 对于反直觉、非通用的业务逻辑（如特定的计算公式、特殊的日期处理规则），必须在代码旁通过注释详细说明其**业务背景**和**决策依据**。
    *   **收益**: 防止后续维护者（或未来的 AI）误删"看起来多余但实际至关重要"的逻辑。

### 7. 🧩 模块化隔离原则 (Modular Isolation Principles)
*   **核心原则**: 随着系统复杂度增加，必须强制执行模块隔离，防止"牵一发而动全身"。
*   **通用实践**:
    *   **独立 JS 文件**: 如果是一个集成应用，每个业务模块必须有独立的 JS 文件（如 `iqc.js`, `supplier.js`），严禁将所有逻辑堆砌在 `main.js` 或 `ui.js` 中。
    *   **独立 CSS 或命名空间**: 每个业务模块的 CSS 必须独立文件，或在单文件中使用严格的命名空间（如 `.iqc-container`, `.supplier-card`）进行隔离。
    *   **共享组件提取**: 共享组件（如 API 请求封装、通用的 Loading 动画、模态框基类）必须提取到独立的 `utils.js` 或 `common.js` 中，供各模块调用。
    *   **重构阈值**: 当一个文件超过一定行数（如 500 行）或包含超过 2 个不同业务模块的逻辑时，强制触发重构拆分。
    *   **收益**: 降低耦合度，确保修改一个模块的功能绝不影响另一个模块的稳定性。

### 8. 🌐 全局命名空间管理原则 (Global Namespace Management)
*   **核心原则**: 避免全局对象命名冲突，建立清晰的模块边界。
*   **通用实践**:
    *   **命名规范**:
        *   模块级工具对象: `window.{moduleName}Utils` (如: `window.supplierUIUtils`)
        *   模块级服务对象: `window.{moduleName}Services` (如: `window.supplierServices`)
        *   严禁使用通用名称: 避免使用 `window.utils`、`window.uiUtils`、`window.helper` 等模糊命名
    *   **依赖检查**: 在构造函数中检查必要依赖，明确报错信息
        ```javascript
        constructor() {
          if (!window.supplierServices) {
            throw new Error('SupplierUIUtils 依赖 SupplierServices，请确保加载顺序正确');
          }
        }
        ```
    *   **HTML加载顺序**: 按依赖关系从底层到上层依次加载
        ```html
        <!-- 1. 服务层 (最底层，无依赖) -->
        <script src="modules/supplier/services/supplier-services.js"></script>
        <!-- 2. UI工具层 (依赖服务层) -->
        <script src="modules/supplier/ui/ui-utils.js"></script>
        <!-- 3. 控制层 (依赖前两层) -->
        <script src="modules/supplier.js"></script>
        ```
    *   **收益**: 避免命名冲突，明确模块边界，提供清晰的错误信息，确保模块间正确的加载顺序。

## 🚨 代码编辑铁律（Code Editing Best Practices for Antigravity）

**⚠️⚠️⚠️ 强制要求 ⚠️⚠️⚠️**

**每次修改文件前，必须先用 view_file 查看本节内容，回顾所有规则！**

**这些规则必须在每次使用 Antigravity 编辑代码前严格遵守，违反将导致文件损坏！**

### 核心问题：工具的"尽力而为"行为

Antigravity 的 `replace_file_content` 和 `multi_replace_file_content` 工具在 `TargetContent` 不精确匹配时，会"尽力而为"地应用修改。这常常导致：
- ✅ 目标行被正确修改
- ❌ 但周围大量代码被意外删除或移位

### 🎯 精确外科手术式修改原则

1. **永远不要贪婪匹配**
   - ❌ **错误示例**：TargetContent 包含 50 行代码只为改其中 1 行
   - ✅ **正确做法**：只匹配需要修改的 1-3 行，加最少的上下文（1-2行）
   - **原因**：大块 TargetContent 极易因空格/换行符不匹配而失败

2. **多处修改必须用 multi_replace_file_content**
   - ❌ **错误**：用 `replace_file_content` 替换第 10-100 行来改第 10 行和第 100 行
   - ✅ **正确**：用 `multi_replace_file_content`，两个独立的 ReplacementChunk
   - **原因**：中间的 90 行代码会被完整保留，不会被误删

3. **TargetContent 必须字符级精确匹配**
   - 必须包含所有空格、制表符、换行符
   - 使用 `view_file` 查看确切内容后再复制
   - Windows 文件是 `\r\n`，不是 `\n`
   - **工具行为**：不精确匹配时会"尽力而为"应用修改，常导致大量代码被删除

4. **小步迭代，频繁验证**
   - 每次只改一个小功能点
   - 改完立即用 `view_file` 验证
   - 发现问题立即 `git restore`

5. **死循环预防（3 次规则）**
   - 如果同一个文件被搞坏 3 次，**立即停止**
   - 不要继续尝试同样的方法
   - 改用其他策略或请用户手动修改

### 📋 编辑前必做检查清单

- [ ] 用 `view_file` 查看最新内容和确切行号
- [ ] TargetContent 精确复制（包括所有空格和换行）
- [ ] 优先使用 `multi_replace_file_content`
- [ ] 每个 chunk 尽可能小（不超过 20 行）
- [ ] 准备好 `git restore` 命令以防失败

### 🛠️ 工具选择决策树

```
需要修改文件？
├─ 只改 1 处且少于 20 行？
│  └─ 用 replace_file_content（TargetContent 尽量小）
└─ 改多处 OR 单处超过 20 行？
   └─ 用 multi_replace_file_content（每处一个独立 chunk）
```

### ⚠️ 危险信号（立即停止并回滚）

- 文件大小突然减少超过 10%
- diff 显示删除的行数远超预期
- 连续 3 次修改同一文件失败
- TargetContent 超过 30 行

### 🔧 失败后的恢复流程

1. **立即回滚**：`git restore <file>`
2. **分析原因**：通常是 TargetContent 不精确匹配，并持续优化到claude.md
3. **改进策略**：
   - 使用更小的 chunk
   - 用 `multi_replace_file_content` 替代 `replace_file_content`
   - 确保 TargetContent 字符级精确
4. **3 次规则**：如果 3 次仍失败，停止并请用户手动修改

### 📚 参考文档

详细规则请参考项目中的 `code_edit_best_practices.md` 文件。

---

## 缓存污染处理原则（2025-11-26添加）

当遇到数据切换功能异常时，优先检查缓存机制：

**问题识别**：不同参数（如年份）的API调用返回相同数据，通常是HTTP缓存污染

**解决方案**：实现智能缓存策略
- 按参数分别缓存（localStorage + 唯一键名）
- 设置短期过期时间（5-10分钟）
- 绕过HTTP缓存（时间戳参数）
- 提供缓存状态日志

**核心原则**：可控缓存优于盲目禁用，性能与准确性并重

**实际案例**：SQE系统年份切换功能 - HTTP缓存导致切换年份后仍显示旧数据，通过智能缓存策略解决。

**代码重复与混乱处理原则：** 在开发过程中必须警惕代码重复和逻辑混乱：
1. **问题预防**：每次添加新功能前，先搜索现有代码是否已有类似逻辑
2. **重复识别**：同文件中同名方法、多处相同的条件判断、多套冲突的缓存策略
3. **紧急修复优先级**：
   - 🚨 **P0**: 影响功能的重复（如API方法重复定义）
   - 🟡 **P1**: 性能相关的重复（如重复计算）
   - 🟢 **P2**: 维护性相关的重复（如重复的类型判断）
4. **修复策略**：
   - 删除重复代码，保留功能更完善的版本
   - 统一策略，避免多套逻辑冲突
   - 优先保证软件不失效，再逐步优化
5. **验证方法**：修复后必须搜索确认重复已消除，并测试核心功能

**实际案例**：SQE系统架构优化 - 发现API方法重复定义、缓存策略冲突，通过删除重复代码和统一策略解决。

--- 

## 🏷️ **代码标记规范提醒**

**致所有AI协作者**：在修改代码前，请优先使用以下标记工具来标识关键代码位置：

### 📋 **标记格式**
```javascript
// 🎯 [标记类型] 简要描述 - 修改指南
// 📍 影响范围说明
// 🔗 关联的文件/功能
```

### 🎯 **标记类型**
- **[CORE-LOGIC]** - 核心业务逻辑
- **[API-ENDPOINT]** - API接口定义
- **[DATA-FLOW]** - 数据流向处理
- **[CONFIG]** - 配置参数
- **[HELPER]** - 辅助函数
- **[UI-EVENT]** - 用户界面事件
- **[CACHE]** - 缓存处理逻辑

### ⚠️ **标记原则**
1. **必要性优先** - 只标记真正关键的代码
2. **不影响运行** - 标记不能破坏程序功能
3. **清晰明确** - 标记要能让其他AI快速理解
4. **保持更新** - 代码变更时同步更新标记

**记住**：标记是为了帮助后续协作，不是为了标记而标记！
