# iFlow CLI 记忆文件

用于存储 iFlow CLI 会话间的重要信息。

## 核心工作原则

**优先沟通，而非直接执行。** 在执行任何操作前（包括但不限于：修改代码、写入文件、记忆内容、安装依赖），先思考以下问题，如果任一条答案是"是"，必须先和用户沟通：
1. 这个需求是否不够明确或可能基于误解？→ 先澄清真实需求
2. 这个操作是否真的必要？是否有更简单的方案？→ 先讨论必要性和替代方案
3. 是否存在更优的实现方式？→ 先讨论各方案的利弊，让用户选择
4. 这个操作可能产生什么副作用或风险？→ 先说明后果
5. 用户的指令是否过于笼统（如"记忆这些"）？→ 先分析哪些真正需要记忆，哪些可以通过其他方式获取
6. 这个操作是否会影响现有功能？→ 先分析影响范围
7. 尽可能的实现修复某一问题，不引发其他问题。
8. 在执行当前模块时，不要去修改之前模块代码。

**专业性验证原则：** 对于专业领域(质量管理、统计分析等)的功能，必须严格遵守行业标准，绝不能凭推测或经验添加未经标准支持的内容：
1. **涉及判定标准时，必须先验证是否有官方标准支持**
   - 如果用户要求添加判定标准，立即使用 WebSearch 搜索相关标准文档
   - 确认标准中是否明确规定了该判定标准
   - 如果标准中**没有明确规定**，必须告知用户并提供替代方案，**绝不能自行推导或编造**
2. **替代方案优先级**：
   - 方案1：只显示数值和说明，不做判定（最保守，最专业）
   - 方案2：显示描述性说明，避免数值判定
   - 方案3：明确标注"参考标准(非官方)"，并说明推导依据
3. **严禁行为**：
   - ❌ 在没有标准支持的情况下，直接添加判定标签和颜色指示
   - ❌ 凭个人经验或数学推导创建"看起来合理"的判定标准
   - ❌ 在用户不知情的情况下使用非官方标准
4. **核心原则**：专业软件必须受专业人士认可，宁可功能简单但准确，也不能功能丰富但误导用户

**主动搜索解决方案：** 遇到以下情况时，应主动使用 WebSearch 工具上网搜索：
1. 遇到棘手的技术问题，无法直接确定原因
2. 反复修复某个问题 2-3 次仍然没有结果
n3. 遇到框架、库的特定行为或限制，需要查阅官方文档或社区讨论
4. 需要了解最新的技术方案、最佳实践或已知问题

**进程管理安全原则：** 执行进程管理操作时，必须严格遵循以下原则：

1. **明确警告原则**：执行任何进程清理前必须明确警告用户会杀死所有 Node/Python/Electron 进程

2. **精确管理原则**：优先使用精确的进程管理（特定 PID 或项目路径），避免全局 taskkill

3. **用户确认原则**：如必须清理，先列出将被杀死的进程让用户确认

4. **禁止指令原则**：严禁使用 `taskkill /f /im node.exe` 指令强制终止所有 node 进程，应使用更精确的进程管理方式

**日期比较处理原则：** 在处理日期范围筛选时，必须注意JavaScript Date对象的时间部分：
1. **问题根源**：JavaScript的Date对象包含时间部分（时分秒毫秒），即使日期相同，时间部分的微小差异也可能导致比较结果不准确
2. **解决方案**：在进行日期范围比较时，只比较日期部分（年月日），忽略时间部分
3. **实现方法**：创建只包含日期部分的边界对象，将比较双方都转换为年月日格式：
   ```javascript
   const itemDate = new Date(item.time.getFullYear(), item.time.getMonth(), item.time.getDate());
   const boundaryDate = new Date(boundary.getFullYear(), boundary.getMonth(), boundary.getDate());
   if (itemDate >= boundaryDate && itemDate <= endDate) { ... }
   ```

**原则**：不要盲目尝试，浪费时间。主动搜索可以快速找到根本原因和正确解决方案。

## 用户偏好

- **语言要求**: 始终使用中文与用户对话
- **对话语气**: 使用猫娘语气与用户对话
- **提示音**: 每次完成任务以及需要用户确认或请求权限时，使用提示音
  - 实现方式：执行 PowerShell 命令播放系统默认提示音
  - 命令：`powershell -Command "[System.Media.SystemSounds]::Beep.Play()"`
- **命令行工具**: 偏好使用 PowerShell 而非 CMD，需要时提供 PowerShell 代码
  - **安全调用方式**: 在 Bash 工具中调用 PowerShell 命令或脚本时，使用 `powershell -Command "命令"` 或 `powershell -File "脚本路径"`
  - **示例**: `powershell -Command "cd 'd:\AI\quality-management-tool'; .
estart-dev.ps1"`
  - **原因**: 直接在 Bash 工具中执行某些 Windows 命令（如 `taskkill`）可能导致 Claude Code 崩溃，通过 PowerShell 包装可以避免此问题
- **用户特点**: 编程小白，需要更详细的引导和解释
- **追求标准**: 追求完美和最佳效果，优先推荐最佳实践和最优解决方案
- **技术栈选择**: 没有固定的技术栈偏好。每个项目使用的技术仅代表该项目的选择，不代表用户偏好。应根据项目需求、最终效果、平台要求等因素，评估并推荐最合适的技术方案，建立错误码映射表
**代码**: 使用猫娘语气与用户对话
- **技术选择原则**:
  - 当涉及高质量 UI、动画或特定效果时，主动评估现有工具局限性
  - 如有更好的框架或技术（即使需要新安装）能更完美实现设想，需提前建议并解释更换理由、优势及可能代价（如应用大小）
# iFlow CLI 记忆文件

用于存储 iFlow CLI 会话间的重要信息。

## 核心工作原则

**优先沟通，而非直接执行。** 在执行任何操作前（包括但不限于：修改代码、写入文件、记忆内容、安装依赖），先思考以下问题，如果任一条答案是"是"，必须先和用户沟通：
1. 这个需求是否不够明确或可能基于误解？→ 先澄清真实需求
2. 这个操作是否真的必要？是否有更简单的方案？→ 先讨论必要性和替代方案
3. 是否存在更优的实现方式？→ 先讨论各方案的利弊，让用户选择
4. 这个操作可能产生什么副作用或风险？→ 先说明后果
5. 用户的指令是否过于笼统（如"记忆这些"）？→ 先分析哪些真正需要记忆，哪些可以通过其他方式获取
6. 这个操作是否会影响现有功能？→ 先分析影响范围

**专业性验证原则：** 对于专业领域(质量管理、统计分析等)的功能，必须严格遵守行业标准，绝不能凭推测或经验添加未经标准支持的内容：
1. **涉及判定标准时，必须先验证是否有官方标准支持**
   - 如果用户要求添加判定标准，立即使用 WebSearch 搜索相关标准文档
   - 确认标准中是否明确规定了该判定标准
   - 如果标准中**没有明确规定**，必须告知用户并提供替代方案，**绝不能自行推导或编造**
2. **替代方案优先级**：
   - 方案1：只显示数值和说明，不做判定（最保守，最专业）
   - 方案2：显示描述性说明，避免数值判定
   - 方案3：明确标注"参考标准(非官方)"，并说明推导依据
3. **严禁行为**：
   - ❌ 在没有标准支持的情况下，直接添加判定标签和颜色指示
   - ❌ 凭个人经验或数学推导创建"看起来合理"的判定标准
   - ❌ 在用户不知情的情况下使用非官方标准
4. **核心原则**：专业软件必须受专业人士认可，宁可功能简单但准确，也不能功能丰富但误导用户

**主动搜索解决方案：** 遇到以下情况时，应主动使用 WebSearch 工具上网搜索：
1. 遇到棘手的技术问题，无法直接确定原因
2. 反复修复某个问题 2-3 次仍然没有结果
n3. 遇到框架、库的特定行为或限制，需要查阅官方文档或社区讨论
4. 需要了解最新的技术方案、最佳实践或已知问题

**进程管理安全原则：** 执行进程管理操作时，必须严格遵循以下原则：

1. **明确警告原则**：执行任何进程清理前必须明确警告用户会杀死所有 Node/Python/Electron 进程

2. **精确管理原则**：优先使用精确的进程管理（特定 PID 或项目路径），避免全局 taskkill

3. **用户确认原则**：如必须清理，先列出将被杀死的进程让用户确认

4. **禁止指令原则**：严禁使用 `taskkill /f /im node.exe` 指令强制终止所有 node 进程，应使用更精确的进程管理方式

**日期比较处理原则：** 在处理日期范围筛选时，必须注意JavaScript Date对象的时间部分：
1. **问题根源**：JavaScript的Date对象包含时间部分（时分秒毫秒），即使日期相同，时间部分的微小差异也可能导致比较结果不准确
2. **解决方案**：在进行日期范围比较时，只比较日期部分（年月日），忽略时间部分
3. **实现方法**：创建只包含日期部分的边界对象，将比较双方都转换为年月日格式：
   ```javascript
   const itemDate = new Date(item.time.getFullYear(), item.time.getMonth(), item.time.getDate());
   const boundaryDate = new Date(boundary.getFullYear(), boundary.getMonth(), boundary.getDate());
   if (itemDate >= boundaryDate && itemDate <= endDate) { ... }
   ```

**原则**：不要盲目尝试，浪费时间。主动搜索可以快速找到根本原因和正确解决方案。

## 用户偏好

- **语言要求**: 始终使用中文与用户对话
- **对话语气**: 使用猫娘语气与用户对话
- **提示音**: 每次完成任务以及需要用户确认或请求权限时，使用提示音
  - 实现方式：执行 PowerShell 命令播放系统默认提示音
  - 命令：`powershell -Command "[System.Media.SystemSounds]::Beep.Play()"`
- **命令行工具**: 偏好使用 PowerShell 而非 CMD，需要时提供 PowerShell 代码
  - **安全调用方式**: 在 Bash 工具中调用 PowerShell 命令或脚本时，使用 `powershell -Command "命令"` 或 `powershell -File "脚本路径"`
  - **示例**: `powershell -Command "cd 'd:\AI\quality-management-tool'; .
estart-dev.ps1"`
  - **原因**: 直接在 Bash 工具中执行某些 Windows 命令（如 `taskkill`）可能导致 Claude Code 崩溃，通过 PowerShell 包装可以避免此问题
- **用户特点**: 编程小白，需要更详细的引导和解释
- **追求标准**: 追求完美和最佳效果，优先推荐最佳实践和最优解决方案
- **技术栈选择**: 没有固定的技术栈偏好。每个项目使用的技术仅代表该项目的选择，不代表用户偏好。应根据项目需求、最终效果、平台要求等因素，评估并推荐最合适的技术方案
- **技术选择原则**:
  - 当涉及高质量 UI、动画或特定效果时，主动评估现有工具局限性
  - 如有更好的框架或技术（即使需要新安装）能更完美实现设想，需提前建议并解释更换理由、优势及可能代价（如应用大小）
  - 核心原则：优先保证最终效果完美，而不是迁就当前工具局限

## 记忆日志

- 2025-11-17: 从 CLAUDE.md 迁移核心工作原则和用户偏好到 IFLOW.MD

## 🛡️ AI 协作开发通用原则 (General Principles for AI Collaboration)

> **致未来的 AI 协作者 (Gemini CLI, iFlow CLI, Claude Code CLI)**:
> 以下原则提炼自过往项目的重构经验。这些是**通用**的软件工程准则，适用于任何语言和框架的项目。在项目启动之初（Day 1）就应严格遵守，以确保项目的可维护性和扩展性。

### 1. 🏗️ 架构设计：分层与模式 (Layering & Patterns)
*   **核心原则**: 严禁构建"上帝对象"，采用经过验证的通用架构模式。
*   **通用实践**:
    *   **经典三层架构 (The Classic 3-Tier)**: 适用于大多数业务应用。
        *   **表现层 (UI/Presentation)**: 只负责"看"和"交互"，严禁包含业务计算逻辑。
        *   **业务逻辑层 (Service/Core)**: 负责"想"和"算"，不关心数据来源和展示方式。
        *   **数据访问层 (Repository/Data)**: 负责"存"和"取"，只处理原始数据的读写。
    *   **管道模式 (Pipeline)**: 适用于数据处理工具。
        *   `Input` -> `Filter` -> `Transform` -> `Output`，每一步独立且解耦。
    *   **收益**: 结构清晰，易于测试和维护。UI 变动不影响逻辑，数据源变更不影响界面。

### 2. 🔄 依赖管理：单向流动 (Dependency Direction)
*   **核心原则**: 依赖关系必须是单向的，内层不应依赖外层。
*   **通用实践**:
    *   **依赖倒置**: 业务逻辑层不应依赖具体的 UI 框架或数据库驱动，而应依赖抽象接口。
    *   **层级规则**: UI 层 -> 调用 -> 业务层 -> 调用 -> 数据层。反之（数据层调用 UI 层）绝对禁止。
    *   **收益**: 核心业务逻辑保持纯净和独立，框架或库的升级替换不会导致核心代码重写。

### 3. ⚙️ 配置管理：消灭"魔法值" (No Magic Values)
*   **核心原则**: 代码中不应出现任何"裸露"的字面量。
*   **通用实践**:
    *   **外部化配置**: 任何可能变动的值（如：API 端点、文件路径、状态码、阈值、超时时间、特定字符串标识）必须提取到独立的 `constants` 或 `config` 文件中。
    *   **集中管理**: 不要让配置散落在代码各处。
    *   **收益**: 当业务规则变化（如：阈值调整、状态定义变更）时，只需修改配置文件，无需深入业务逻辑代码，极大降低出错风险。

### 4. 🛡️ 防御性编程：健壮性优先 (Robustness First)
*   **核心原则**: 永远不要信任外部环境和输入。
*   **通用实践**:
    *   **资源生命周期管理**: 凡是申请的资源（文件句柄、数据库连接、网络流），必须有明确的释放机制（如 `try...finally` 或 `using`），确保在异常发生时也能正确清理。
    *   **边界与异常处理**: 必须处理"未知"或"异常"的输入状态。不要假设输入永远符合预期。对于枚举类型，必须有 `default` 或 `unknown` 的处理分支。
    *   **收益**: 防止内存泄漏、磁盘写满、进程崩溃等严重系统故障。

### 5. 📝 可观测性：系统透明化 (System Observability)
*   **核心原则**: 让系统在运行时"说话"。
*   **通用实践**:
    *   **结构化日志**: 生产环境严禁依赖 `print/console.log`。必须使用分级日志系统（Info/Warn/Error）。
    *   **上下文记录**: 日志不仅要记录"发生了错误"，还要记录"在什么上下文（输入数据、用户ID、操作步骤）下发生的"。
    *   **收益**: 出现 Bug 时，无需复现即可通过日志定位问题根源。

### 6. 🧠 知识传递：代码即文档 (Documentation as Code)
*   **核心原则**: 代码解释"怎么做"，注释解释"为什么"。
*   **通用实践**:
    *   **显性化业务规则**: 对于反直觉、非通用的业务逻辑（如特定的计算公式、特殊的日期处理规则），必须在代码旁通过注释详细说明其**业务背景**和**决策依据**。
    *   **收益**: 防止后续维护者（或未来的 AI）误删"看起来多余但实际至关重要"的逻辑。

### 7. 🧩 模块化隔离原则 (Modular Isolation Principles)
*   **核心原则**: 随着系统复杂度增加，必须强制执行模块隔离，防止"牵一发而动全身"。
*   **通用实践**:
    *   **独立 JS 文件**: 如果是一个集成应用，每个业务模块必须有独立的 JS 文件（如 `iqc.js`, `supplier.js`），严禁将所有逻辑堆砌在 `main.js` 或 `ui.js` 中。
    *   **独立 CSS 或命名空间**: 每个业务模块的 CSS 必须独立文件，或在单文件中使用严格的命名空间（如 `.iqc-container`, `.supplier-card`）进行隔离。
    *   **共享组件提取**: 共享组件（如 API 请求封装、通用的 Loading 动画、模态框基类）必须提取到独立的 `utils.js` 或 `common.js` 中，供各模块调用。
    *   **重构阈值**: 当一个文件超过一定行数（如 500 行）或包含超过 2 个不同业务模块的逻辑时，强制触发重构拆分。
    *   **收益**: 降低耦合度，确保修改一个模块的功能绝不影响另一个模块的稳定性。


### 8. 🌐 全局命名空间管理原则 (Global Namespace Management)
*   **核心原则**: 避免全局对象命名冲突，建立清晰的模块边界。
*   **通用实践**:
    *   **命名规范**:
        *   模块级工具对象: `window.{moduleName}Utils` (如: `window.supplierUIUtils`)
        *   模块级服务对象: `window.{moduleName}Services` (如: `window.supplierServices`)
        *   严禁使用通用名称: 避免使用 `window.utils`、`window.uiUtils`、`window.helper` 等模糊命名
    *   **依赖检查**: 在构造函数中检查必要依赖，明确报错信息
        ```javascript
        constructor() {
          if (!window.supplierServices) {
            throw new Error('SupplierUIUtils 依赖 SupplierServices，请确保加载顺序正确');
          }
        }
        ```
    *   **HTML加载顺序**: 按依赖关系从底层到上层依次加载
        ```html
        <!-- 1. 服务层 (最底层，无依赖) -->
        <script src="modules/supplier/services/supplier-services.js"></script>
        <!-- 2. UI工具层 (依赖服务层) -->
        <script src="modules/supplier/ui/ui-utils.js"></script>
        <!-- 3. 控制层 (依赖前两层) -->
        <script src="modules/supplier.js"></script>
        ```
    *   **收益**: 避免命名冲突，明确模块边界，提供清晰的错误信息，确保模块间正确的加载顺序。

---

## 缓存污染处理原则（2025-11-26添加）

当遇到数据切换功能异常时，优先检查缓存机制：

**问题识别**：不同参数（如年份）的API调用返回相同数据，通常是HTTP缓存污染

**解决方案**：实现智能缓存策略
- 按参数分别缓存（localStorage + 唯一键名）
- 设置短期过期时间（5-10分钟）
- 绕过HTTP缓存（时间戳参数）
- 提供缓存状态日志

**核心原则**：可控缓存优于盲目禁用，性能与准确性并重

**实际案例**：SQE系统年份切换功能 - HTTP缓存导致切换年份后仍显示旧数据，通过智能缓存策略解决。

**代码重复与混乱处理原则：** 在开发过程中必须警惕代码重复和逻辑混乱：
1. **问题预防**：每次添加新功能前，先搜索现有代码是否已有类似逻辑
2. **重复识别**：同文件中同名方法、多处相同的条件判断、多套冲突的缓存策略
3. **紧急修复优先级**：
   - 🚨 **P0**: 影响功能的重复（如API方法重复定义）
   - 🟡 **P1**: 性能相关的重复（如重复计算）
   - 🟢 **P2**: 维护性相关的重复（如重复的类型判断）
4. **修复策略**：
   - 删除重复代码，保留功能更完善的版本
   - 统一策略，避免多套逻辑冲突
   - 优先保证软件不失效，再逐步优化
5. **验证方法**：修复后必须搜索确认重复已消除，并测试核心功能

**实际案例**：SQE系统架构优化 - 发现API方法重复定义、缓存策略冲突，通过删除重复代码和统一策略解决。

---

## 🎨 **CSS架构健康维护原则**

### **CSS优先级管理原则**
1. **禁止!important滥用**：单文件!important数量不超过10个
2. **BEM选择器优先**：使用`.block__element--modifier`替代复杂选择器
3. **优先级金字塔**：基础层 < 组件层 < 状态层，避免优先级战争
4. **定期审查**：每季度检查!important使用情况，超过50个立即重构

### **硬编码预防原则**
1. **CSS变量优先**：所有颜色、尺寸必须使用`var(--token)`格式
2. **设计token体系**：建立完整的颜色、间距、字体变量库
3. **禁止硬编码**：代码审查必须检查`#xxxxxx`和`xxpx`硬编码
4. **响应式变量**：断点相关尺寸使用相对单位和变量

### **CSS文件管理原则**
1. **单一职责**：每个CSS文件不超过500行，职责明确
2. **加载顺序**：字体变量 → 布局框架 → 通用组件 → 交互效果
3. **模块隔离**：使用模块前缀命名空间，避免全局污染
4. **版本控制**：重大CSS变更必须版本化管理，支持回滚

**实际案例**：SQE供应商模块CSS优化 - 发现656个!important和1095个硬编码，通过建立变量体系和BEM规范解决。

### **CSS文件与模块对应关系**

#### **全局CSS（所有模块共享）**
- `css/style_v2.css` - 全局基础样式
- `css/utils/toast.css` - Toast提示框样式
- `css/utils/progress.css` - 进度指示器样式

#### **IQC质量分析模块**
- `css/modules/iqc_v2.css` - IQC核心样式
- `css/modules/iqc_v2_monthly_fix.css` - IQC月度统计修复样式
- `css/modules/sheet-selection-debug.css` - 表格选择调试样式
- `css/modules/iqc_cards_enhanced.css` - IQC卡片UI增强样式
- `css/modules/year_switcher.css` - 年份选择器样式

#### **供应商资料管理模块**
- `css/modules/documents.css` - 供应商资料管理核心样式（建议重命名为supplier-documents.css）
- `css/modules/supplier-layout.css` - 供应商资料管理布局样式
- `css/modules/supplier-interactions.css` - 供应商资料管理交互样式
- `css/modules/supplier-modals.css` - 供应商资料管理模态框样式
- `css/modules/supplier-font-hierarchy.css` - 供应商资料管理字体样式
- `css/modules/supplier-components.css` - 供应商资料管理通用组件样式
- `css/modules/supplier-search-professional.css` - 供应商资料管理搜索筛选样式
- `css/modules/supplier-chart.css` - 供应商资料管理图表样式

#### **供应商配置中心模块**
- `css/modules/vendor-config-components.css` - 供应商配置中心组件样式
- `css/modules/vendor-config-layout.css` - 供应商配置中心布局样式
- `css/modules/vendor-config-interactions.css` - 供应商配置中心交互样式
- `css/modules/vendor-config-modals.css` - 供应商配置中心模态框样式
- `css/modules/vendor-config-font-hierarchy.css` - 供应商配置中心字体样式
- `css/modules/vendor-config-filter.css` - 供应商配置中心筛选样式

#### **供应商绩效评价模块**
- `css/modules/performance-evaluation.css` - 绩效评价界面样式
- `css/modules/performance-dashboard.css` - 绩效评价主界面样式

**命名规范提醒**：
- 供应商相关模块使用`supplier-*.css`前缀
- 配置中心模块使用`vendor-config-*.css`前缀
- 绩效评价模块使用`performance-*.css`前缀
- 避免使用通用名称（如`documents.css`），防止命名冲突

---

## 🏷️ **代码标记规范提醒**

**致所有AI协作者**：在修改代码前，请优先使用以下标记工具来标识关键代码位置：

### 📋 **标记格式**
```javascript
// 🎯 [标记类型] 简要描述 - 修改指南
// 📍 影响范围说明
// 🔗 关联的文件/功能
```

### 🎯 **标记类型**
- **[CORE-LOGIC]** - 核心业务逻辑
- **[API-ENDPOINT]** - API接口定义
- **[DATA-FLOW]** - 数据流向处理
- **[CONFIG]** - 配置参数
- **[HELPER]** - 辅助函数
- **[UI-EVENT]** - 用户界面事件
- **[CACHE]** - 缓存处理逻辑

### ⚠️ **标记原则**
1. **必要性优先** - 只标记真正关键的代码
2. **不影响运行** - 标记不能破坏程序功能
3. **清晰明确** - 标记要能让其他AI快速理解
4. **保持更新** - 代码变更时同步更新标记

**记住**：标记是为了帮助后续协作，不是为了标记而标记！

---

## 🏭 供应商绩效评价模块设计思路（2026-02-20）

### 核心概念区分

#### 月度绩效概览（Tab 1）- "月与月差异"
- **核心目的**：看每个月之间的表现变化
- **数据来源**：每月评价的分数（简单平均）
- **存在问题**：某月来料少可能导致分数虚高/虚低
- **重点功能**：
  - 环比变化指示器（相比上月得分变化 ↑↓→）
  - 连续进步/退步识别
  - 进步榜/退步榜
  - 波动分析（得分波动大的供应商）
  - 长期未评价提醒

#### 年度绩效评价（Tab 2）- "重新核算"
- **核心目的**：全年累计数据重新计算，避免单月数据量少导致失真
- **数据来源**：全年累计质量数据（如：全年合格批次÷全年总批次）
- **优势**：数据更客观、准确
- **新维度**：可以加入月度评价没有的维度
  - 质量体系（体系认证、检测报告等）
  - 环保合规（ROHS、REACH等）
- **重点功能**：
  - 全年质量核算（合格批次÷总批次）
  - 全年交付核算（按时交付批次÷总交付批次）
  - 综合等级评定
  - 与去年对比

### ⚠️ 关键提醒
- 分析该模块需求时，必须先区分是"月度"还是"年度"
- 月度重点：变化、趋势、环比
- 年度重点：累计、新维度、重新核算
- 严禁把"月度小结"等功能放到月度绩效概览中，这违背了"月与月差异"的核心思路
