# 本地资料管理架构设计

**来源**: 供应商资料管理系统产品策划 v2.3 (gemini v0.1)  
**策划日期**: 2025-12-02  
**核心功能**: 系统与本地文件夹自动同步，实现真正的本地资料管理

---

## 🎯 一、核心理念

> "当在系统中删除、新增资料时，本地的某个区域也会对pdf等文件进行调整，以便于真的做到本地资料管理"

系统中的所有文件操作（上传、删除、更新）都会自动同步到本地文件夹，确保本地文件结构与系统数据完全一致。

---

## 🗂️ 二、文件夹结构规范

### 2.1 标准目录结构
```
uploads/
├── {供应商名称}/
│   ├── {物料名称}/
│   │   ├── {证书类型}/
│   │   │   ├── 文件1.pdf
│   │   │   ├── 文件2.pdf
│   │   │   └── ...
│   │   └── ...
│   └── ...
└── ...
```

### 2.2 实际示例结构
```
uploads/
├── 供应商A/
│   ├── 胶带/
│   │   ├── ROHS报告/
│   │   │   ├── 供应商A_电木粉_ROHS_构成_v1_20251101.pdf
│   │   │   └── 供应商A_电木粉_ROHS_构成_v2_20251201.pdf
│   │   ├── REACH报告/
│   │   │   └── 供应商A_电木粉_REACH_构成_v1_20250615.pdf
│   │   ├── MSDS报告/
│   │   │   └── 供应商A_电木粉_MSDS_构成_v1_20250320.pdf
│   │   └── HF报告/
│   │       └── 供应商A_电木粉_HF__构成v1_20250910.pdf
│   └── PIN脚/
│       ├── ROHS报告/
│       ├── REACH报告/
│       ├── MSDS报告/
│       └── HF报告/
├── 供应商B/
│   └── (按相同结构)
├── 供应商C/
│   └── (按相同结构)
└── ...
```

---

## 🔄 三、文件同步机制



### 3.1 上传同步
- **触发时机**: 用户在系统中上传文件时
- **同步动作**: 
  - 自动创建对应的文件夹结构（供应商→物料→证书类型）
  - 将文件保存到对应目录
  - 按命名规范重命名文件
  - 更新数据库记录

### 3.2 删除同步
- **触发时机**: 用户在系统中删除文件记录时
- **同步动作**:
  - 从数据库中删除文件记录
  - 同步删除本地文件夹中的对应文件
  - 如果文件夹为空，可选择是否删除空文件夹
  - 记录删除日志

### 3.3 更新同步
- **触发时机**: 用户更新文件（上传新版本）时
- **同步动作**:
  - 保留历史版本文件（可选择性归档）
  - 将最新版本文件保存到对应目录
  - 按版本号命名规范重命名
  - 更新数据库中的当前版本标识

### 3.4 结构同步
- **触发时机**: 物料结构调整时（新增/删除/重命名物料或构成）
- **同步动作**:
  - 自动调整本地文件夹结构
  - 移动相关文件到新的对应位置
  - 更新文件路径记录
  - 保持数据一致性

---

## 📝 四、文件命名规范

### 4.1 标准命名格式
```
{供应商名称}_{物料名称}_{证书类型}_{构成}_{版本号}_{日期}.{扩展名}
```

### 4.2 命名示例
- `供应商A_电木粉_ROHS_v2_20251201.pdf`
- `供应商B_PIN脚_REACH_v1_20251115.pdf`
- `供应商C_塑胶件_MSDS_v3_20251020.pdf`

### 4.3 版本控制规则
- **版本号格式**: v{数字} (如: v1, v2, v3)
- **自动递增**: 新版本自动递增版本号
- **历史归档**: 历史文件保留在原目录或专门的archive文件夹
- **当前版本**: 最新版本作为主要文件，数据库指向当前版本

---

## 🏗️ 五、技术实现架构

### 5.1 文件操作服务层
```javascript
class LocalFileSyncService {
  // 上传文件同步
  async syncUpload(fileData, supplierInfo, materialInfo, documentType) {
    // 1. 创建文件夹结构
    await this.createFolderStructure(supplierInfo, materialInfo, documentType);
    
    // 2. 生成标准文件名
    const fileName = this.generateFileName(fileData, supplierInfo, materialInfo, documentType);
    
    // 3. 保存文件到本地
    await this.saveFileToLocal(fileData, fileName);
    
    // 4. 更新数据库记录
    await this.updateDatabaseRecord(fileData, fileName);
  }
  
  // 删除文件同步
  async syncDelete(documentId) {
    // 1. 获取文件信息
    const fileInfo = await this.getDocumentInfo(documentId);
    
    // 2. 删除本地文件
    await this.deleteLocalFile(fileInfo.filePath);
    
    // 3. 删除数据库记录
    await this.deleteDatabaseRecord(documentId);
    
    // 4. 清理空文件夹
    await this.cleanEmptyFolders(fileInfo.folderPath);
  }
  
  // 更新文件同步
  async syncUpdate(documentId, newFileData) {
    // 1. 获取当前文件信息
    const currentInfo = await this.getDocumentInfo(documentId);
    
    // 2. 归档历史版本
    await this.archivePreviousVersion(currentInfo);
    
    // 3. 保存新版本
    await this.saveNewVersion(documentId, newFileData);
    
    // 4. 更新数据库
    await this.updateVersionInfo(documentId, newFileData);
  }
}
```

### 5.2 文件夹管理工具
```javascript
class FolderManager {
  // 创建文件夹结构
  async createFolderStructure(supplierName, materialName, documentType) {
    const basePath = 'uploads/';
    const supplierPath = path.join(basePath, supplierName);
    const materialPath = path.join(supplierPath, materialName);
    const documentPath = path.join(materialPath, documentType);
    
    // 递归创建文件夹
    await fs.ensureDir(documentPath);
    
    return {
      supplierPath,
      materialPath,
      documentPath
    };
  }
  
  // 清理空文件夹
  async cleanEmptyFolders(folderPath) {
    const isEmpty = await this.isFolderEmpty(folderPath);
    if (isEmpty) {
      await fs.remove(folderPath);
      // 递归清理上级空文件夹
      const parentPath = path.dirname(folderPath);
      if (parentPath !== 'uploads/') {
        await this.cleanEmptyFolders(parentPath);
      }
    }
  }
  
  // 移动文件夹（结构调整时）
  async moveFolderStructure(oldPath, newPath) {
    await fs.move(oldPath, newPath);
    // 更新数据库中所有相关文件的路径
    await this.updateFilePathsInDatabase(oldPath, newPath);
  }
}
```

---

## 🔧 六、实现要点

### 6.1 数据一致性保证
- **事务处理**: 文件操作和数据库操作在同一事务中
- **错误回滚**: 操作失败时自动回滚文件和数据库更改
- **状态检查**: 定期检查本地文件与数据库记录的一致性

### 6.2 性能优化
- **异步操作**: 文件操作使用异步处理，避免阻塞
- **批量处理**: 支持批量文件操作，提高效率
- **缓存机制**: 文件路径信息缓存，减少磁盘访问

### 6.3 错误处理
- **磁盘空间检查**: 上传前检查磁盘空间
- **权限检查**: 确保有文件读写权限
- **网络异常**: 网络异常时的重试机制
- **日志记录**: 详细记录所有文件操作日志

---

## 📊 七、监控与维护

### 7.1 同步状态监控
- **实时监控**: 监控文件同步状态
- **异常报警**: 同步失败时发送报警
- **统计报告**: 定期生成同步统计报告

### 7.2 数据修复工具
- **一致性检查**: 检查本地文件与数据库的一致性
- **自动修复**: 发现不一致时的自动修复机制
- **手动修复**: 提供手动修复工具

### 7.3 备份策略
- **定期备份**: 定期备份整个uploads目录
- **增量备份**: 支持增量备份机制
- **恢复机制**: 快速恢复机制

---

## 🎯 八、用户体验

### 8.1 操作透明性
- **进度显示**: 文件操作时显示进度
- **状态反馈**: 实时反馈操作状态
- **错误提示**: 友好的错误提示信息

### 8.2 便捷性
- **快速访问**: 可直接从系统快速访问本地文件
- **批量操作**: 支持批量文件操作
- **预览功能**: 支持文件预览功能

---

## 📋 九、实施计划

### 9.1 第一阶段：基础架构
- [ ] 实现LocalFileSyncService基础服务
- [ ] 实现FolderManager文件夹管理
- [ ] 建立文件命名规范
- [ ] 实现基础的同步机制

### 9.2 第二阶段：完善功能
- [ ] 实现错误处理和回滚机制
- [ ] 实现性能优化
- [ ] 实现监控和报警
- [ ] 实现数据修复工具

### 9.3 第三阶段：优化体验
- [ ] 实现进度显示和状态反馈
- [ ] 实现文件预览功能
- [ ] 实现批量操作
- [ ] 实现备份和恢复机制

---

## 🎉 十、预期效果

### 10.1 功能效果
- ✅ 系统与本地文件完全同步
- ✅ 文件夹结构清晰规范
- ✅ 支持版本管理和历史追溯
- ✅ 自动化程度高，减少人工操作

### 10.2 用户体验
- ✅ 操作简单直观
- ✅ 反馈及时准确
- ✅ 错误处理友好
- ✅ 性能稳定可靠

### 10.3 管理效益
- ✅ 数据一致性保证
- ✅ 维护成本降低
- ✅ 工作效率提升
- ✅ 风险控制加强

---

**总结**: 通过本地资料管理架构设计，实现了系统与本地文件的完美同步，用户在系统中的所有操作都会自动反映到本地文件系统，真正做到了"本地资料管理"的目标。这不仅提高了数据可靠性，也为用户提供了更加灵活和便捷的文件管理方式。